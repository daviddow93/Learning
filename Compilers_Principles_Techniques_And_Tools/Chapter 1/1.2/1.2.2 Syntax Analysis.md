The second phase of the compiler is syntax analysis or parsing.
The parser uses the first components of the tokens produced by the lexical analyzer to create a tree-like intermediate representation that depicts the grammatical structure of the token stream. A typical representation is a syntax tree, where each interior node  represents  an operation and the children of that node represent the arguments of that operation.


position = initial + rate \* 60

\<id,1\> \<=\> \<\id,2\> \<\+\> \<id,3\> \<\*\> \<60\>

it's hard to represent the tree here, but imagine an equal sign branching on the left with the first identifier token, and on the right is the \+ sign, and the left child of the + sign is the second identifier, and the right child is the multiplication sign. The left child of the multiplication sign is identifier 3, and the right child is the inttofloat operation. The only child of inttofloat is 60.

id ,1 <-- = -- > +
id,2 <-- + --> \*
id,3 <-- \* --> inttofloat
inttofloat -->60

with this tree, it's implicitly implied that we need to do the multiplication of 60 and rate first, and then the result needs to be added to initial, and finally, it's assigned to position.

This lines up with the usual order of precedence for algebra, where multiplication needs to occur before addition.

In chapter 4, context free grammars will be used to specify grammatical structures of programming languages.