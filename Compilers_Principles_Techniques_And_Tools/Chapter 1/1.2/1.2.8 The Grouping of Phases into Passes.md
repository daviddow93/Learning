The discussion of phases deals with the logical organization of the compiler. Activities from several phases may be grouped together into a pass the reads an input file and writes an output file. For example, the front-end phases of lexical analysis, syntax analysis, semantic analysis, and intermediate code generation might be grouped together into one pass. Code optimization might be an optional pass. There could then be a back-end pass consisting of code generation for a particular target machine.

Some compiler collections are carefully designed around intermediate representations that allow the front end for a particular language to interface with the back end for a certain target machine. With these collections, we can produce compilers for different source languages for one target machine by combining different front ends with the back end for a target machine. Conversely, we can produce compilers for different target machines, by combining a front end with back ends for different target machines.

```
Visually speaking:

Language A -> Compiler A -> Machine Code Type A (i.e. AMD64)
Language B -> Compiler A -> Machine Code Type A
Language C -> Compiler A -> Machine Code Type A

-or-

Language A -> Compiler B -> Machine Code Type A (i.e. AMD64)
Language A -> Compiler B -> Machine Code Type B (i.e. ARM)
Language A -> Compiler B -> Machine Code Type C (i.e. SPARC)

```
